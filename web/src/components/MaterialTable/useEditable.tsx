import React, { useCallback, useMemo } from 'react';
import { IconButton, Input } from '@mui/material';
import {
  Cancel as CancelIcon,
  Delete as DeleteIcon,
  Edit as EditIcon,
  Save as SaveIcon,
} from '@mui/icons-material';

import { flexRender, RowData } from '@tanstack/react-table';
import type {
  MaterialCell,
  MaterialCellContext,
  MaterialColumnDef,
  MaterialTableInstance,
} from './types';
import { makeMaterialStateUpdater } from './utilities';
import { noop } from '../../utils/utilities';

const editColumn = '__edit';
const deleteColumn = '__delete';

/**
 * Default implementation of the row save action.
 * Will update current row values to the edited ones.
 * @param row The row generated by react table
 * @param state Current state of react table
 */
export function defaultOnSaveRow(state: Record<string, any>, { row }: MaterialCellContext<any, any>) {
  Object.keys(state).forEach(key => {
    row.original[key] = state[key];
    row._valuesCache[key] = state[key];
  });
}

/**
 * Simple function that sets the row edit state after a cell has been edited
 * @param newValue The new value for that cell
 * @param rowStates current rowEditStates
 * @param cell current cell that was edited
 */
export function processCellEdit<TData extends RowData, TValue>(newValue: TValue, rowStates: Record<string, TData | undefined>, cell: MaterialCell<TData, TValue>): void {
  const rowState = rowStates[cell.row.id];
  if (!rowState) return;
  (rowState as any)[cell.column.id] = newValue;
}

function DefaultEditCell({ column, getValue, table, cell }: MaterialCellContext<any, any>): React.ReactElement {
  let name = column.columnDef.header;
  if (typeof name !== 'string') {
    name = column.id;
  }
  return (
    <Input
      defaultValue={getValue()}
      onChange={(event => processCellEdit(event.target.value, table.getState().rowEditState, cell))}
      inputProps={{
        'aria-label': `${name} input`,
      }}
    />
  );
}

export const defaultSetEditingRow = ({ table, row }: MaterialCellContext<any, any>, isEditing: boolean) => {
  const updater = makeMaterialStateUpdater('editing', table);
  updater((editing) => ({
    ...editing,
    [row.id]: isEditing,
  }));

  const rowStateUpdater = makeMaterialStateUpdater('rowEditState', table);

  rowStateUpdater((rowEditState) => (isEditing ? {
    ...rowEditState,
    [row.id]: {},
  } : rowEditState));
};

export const useEditColumn = <TData extends RowData>(columns: MaterialColumnDef<TData>[]): MaterialColumnDef<TData, unknown>[] => {
  const onSaveEdit = useCallback((ctx: MaterialCellContext<TData, unknown>) => {
    const {
      row,
      table,
    } = ctx;
    const {
      onSaveRow = defaultOnSaveRow,
      setEditingRow = defaultSetEditingRow,
    } = table.options.meta || {};

    setEditingRow(ctx, false);
    onSaveRow(
      (table.getState().rowEditState[row.id] || {}) as Partial<TData>,
      ctx
    );
  }, []);

  const onCancelEdit = useCallback((ctx: MaterialCellContext<TData, unknown>) => {
    const {
      row,
      table,
    } = ctx;

    const {
      onCancelRow = noop,
      setEditingRow = defaultSetEditingRow,
    } = table.options.meta || {};

    setEditingRow(ctx, false);
    onCancelRow(
      (table.getState().rowEditState[row.id] || {}) as Partial<TData>,
      ctx
    );
  }, []);

  const onDelete = useCallback((ctx: MaterialCellContext<TData, any>) => {
    const {
      row,
      table,
    } = ctx;

    const {
      confirm,
      onDeleteRow = noop,
      setEditingRow = defaultSetEditingRow,
    } = table.options.meta || {};

    if (typeof confirm !== 'function') return;

    confirm({
      description: `Do you want to delete row ${JSON.stringify(row.original)}`,
      confirmationText: 'Delete',
      confirmationButtonProps: { 'aria-label': 'Confirm delete row' },
    })
      .then(() => {
        setEditingRow(ctx, false);
        onDeleteRow(ctx);
      })
      .catch(() => {});
  }, []);

  return useMemo(() => {
    const newColumns: MaterialColumnDef<TData>[] = [
      {
        id: editColumn,
        padding: 'checkbox',
        header: () => null,
        cell: function Cell(ctx: MaterialCellContext<TData, unknown>) {
          const { table, row } = ctx;
          const {
            setEditingRow = defaultSetEditingRow,
            classes = {},
          } = table.options.meta || {};


          return (
            <div className={classes.editCell}>
              {!(table.getState().editing[row.id]) ? (
                <IconButton
                  onClick={() => setEditingRow(ctx, true)}
                  name='edit'
                  aria-label='edit row'
                  size='large'
                >
                  <EditIcon />
                </IconButton>
              ) : (
                <>
                  <IconButton
                    name='save'
                    onClick={() => onSaveEdit(ctx)}
                    aria-label='save row'
                    size='large'
                  >
                    <SaveIcon />
                  </IconButton>
                  <IconButton
                    name='cancel'
                    onClick={() => onCancelEdit(ctx)}
                    aria-label='cancel edit'
                    size='large'
                  >
                    <CancelIcon />
                  </IconButton>
                </>
              )}
            </div>
          );
        },
      },
      ...columns.map((col) => ({
        OriginalCell: col.cell,
        EditCell: col.EditCell || DefaultEditCell,
        ...col,
        cell: function ModifiedCell(ctx: MaterialCellContext<TData, any>) {
          const { table, column, row, cell } = ctx;

          return (
            ((col.enableEditing ?? true) && table.getState().editing[row.id]) ?
              flexRender(column.columnDef.EditCell, ctx) :
              flexRender(column.columnDef.OriginalCell ?? cell.renderValue(), ctx)
          );
        },
      })),
      {
        id: deleteColumn,
        padding: 'checkbox',
        header: () => null,
        cell: function Cell(ctx) {
          return (
            <IconButton
              name='delete'
              onClick={() => onDelete(ctx)}
              aria-label='Delete row'
              size='large'
            >
              <DeleteIcon />
            </IconButton>
          );
        },
      },
    ];

    return newColumns;
  }, [columns, onCancelEdit, onDelete, onSaveEdit]);
};

function useStuff(table: MaterialTableInstance<any>) {
  const {
    enableDeleting = false,
    enableEditing = false,
  } = table.options.meta || {};

  useMemo(() => {
    const newColumns = {
      [editColumn]: enableEditing,
      [deleteColumn]: enableDeleting,
    };
    table.setColumnVisibility((state) => ({
      ...state,
      ...newColumns,
    }));
  }, [enableDeleting, enableEditing, table]);

  return table;
}

/**
 * Parameters accepted by this plugin
 * - onSaveRow: Function called when row is saved. Defaults to `defaultOnSaveRow`
 * - onCancelRow: Function called when row edit was cancelled
 * - onEditRow: Function called when row editing begins
 * - classes.editCell: Class name for edit cell content
 * - disableEditing: boolean that determines whether editing is enabled or not
 */
export const useEditable = <TData extends RowData>(table: MaterialTableInstance<TData>): MaterialTableInstance<TData> => {
  useStuff(table);

  return table;
};
