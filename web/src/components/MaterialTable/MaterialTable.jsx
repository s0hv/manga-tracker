import { ConfirmProvider, useConfirm } from 'material-ui-confirm';
import React, { useCallback, useEffect, useState } from 'react';
import { useSortBy, useTable, usePagination } from 'react-table';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  TableSortLabel,
  TablePagination,
  CircularProgress,
  Skeleton,
} from '@mui/material';
import { darken, styled } from '@mui/material/styles';
import PropTypes from 'prop-types';

import TablePaginationActions from './TablePaginationActions';
import { TableToolbar } from './TableToolbar';
import { useEditable } from './useEditable';

const TableHeadStyled = styled(TableHead)(({ theme }) => ({
  backgroundColor: darken(theme.palette.background.paper, 0.01),
}));

const PaginationContainer = styled('div')({
  display: 'flex',
  justifyContent: 'flex-end',
  alignItems: 'center',
});

const PREFIX = 'MaterialTable';
const classes = {
  editCell: `${PREFIX}-editCell`,
};

const Root = styled('div')({
  [`& .${classes.editCell}`]: {
    display: 'flex',
    justifyContent: 'center',
  },
});

const skeletonCount = new Array(10).fill(0);

/**
 * Renders a table with data generated by react-table with custom hooks
 */
const MaterialTable = (props) => {
  const {
    title,
    columns,
    data,
    sortable = false,
    editable = false,
    deletable = false,
    creatable = false,
    pagination = false,
    rowsPerPage: rowsPerPageInitial = 25,
    onSaveRow,
    onDeleteRow,
    id,
    fetchData,
    rowCount = 0,
    loading = false,
    CreateDialog,
    toolbarProps,
    hooks = [],
    tableOptions = {},
  } = props;

  if (data === null || data === undefined) {
    throw new TypeError('Data not given to table');
  }

  const [rowsPerPage] = useState(rowsPerPageInitial);
  const confirm = useConfirm();

  const {
    getTableProps,
    getTableBodyProps,
    headerGroups,
    rows,
    tableSize,
    prepareRow,
    setPageSize,
    gotoPage,
    state: { pageIndex, pageSize, sortBy },
  } = useTable({
    columns,
    data,
    disableSortBy: !sortable,
    disableDeleting: !deletable,
    disableEditing: !editable,
    disableCreating: !creatable,
    classes,
    onSaveRow,
    onDeleteRow,
    confirm,
    initialState: {
      pageSize: rowsPerPage,
    },
    manualPagination: true,
    pageCount: -1, // This is handled by the TablePagination component
    autoResetPage: false,
    manualSortBy: typeof fetchData === 'function',
    autoResetSortBy: typeof fetchData !== 'function',
    ...tableOptions,
  },
  useSortBy,
  useEditable,
  usePagination,
  ...hooks);

  useEffect(() => {
    if (typeof fetchData !== 'function') return;

    fetchData(pageIndex, pageSize, sortBy);
  }, [fetchData, pageIndex, pageSize, sortBy]);

  const onChangePage = useCallback((e, page) => {
    gotoPage(page);
  }, [gotoPage]);
  const onChangePageSize = useCallback((e) => setPageSize(e.target.value), [setPageSize]);
  const labelDisplayedRows = useCallback(
    ({ page }) => `Page ${page+1} of ${Math.ceil(rowCount/pageSize)}`, [pageSize, rowCount]
  );

  return (
    <Root id={id}>
      <TableToolbar
        title={title}
        DialogComponent={CreateDialog}
        creatable={creatable}
        {...toolbarProps}
      />
      <Table
        size={tableSize}
        aria-label={title}
        {...getTableProps()}
      >
        <colgroup>
          {columns.map(col => <col width={col.width} key={col.accessor} />)}
        </colgroup>
        <TableHeadStyled>
          {headerGroups.map(headerGroup => (
            <TableRow {...headerGroup.getHeaderGroupProps()}>
              {headerGroup.headers.map(col => (
                <TableCell
                  aria-sort={
                    /* eslint-disable-next-line no-nested-ternary */
                    col.isSorted ?
                      (col.isSortedDesc ? 'descending' : 'ascending') :
                      undefined
                  }
                  {...col.getHeaderProps(col.getSortByToggleProps({
                    width: col.widthSuggestion,
                    title: undefined,
                  }))}
                >
                  {col.canSort ? (
                    <TableSortLabel
                      active={col.isSorted}
                      direction={col.isSortedDesc ? 'desc' : 'asc'}
                      hideSortIcon={!sortable}
                    >
                      {col.render('Header')}
                    </TableSortLabel>
                  ) : col.render('Header')}
                </TableCell>
              ))}
            </TableRow>
          ))}
        </TableHeadStyled>
        <TableBody {...getTableBodyProps()} aria-live='polite'>
          {loading && !rows.length && skeletonCount.map((_, i) => (
            // eslint-disable-next-line react/no-array-index-key
            <TableRow key={i} aria-hidden>
              {headerGroups[0].headers.map((h) => (
                <TableCell key={h.id} sx={{ fontSize: '1.2rem' }}>
                  <Skeleton />
                </TableCell>
              ))}
            </TableRow>
          ))}
          {rows.map(row => {
            prepareRow(row);
            return (
              <TableRow {...row.getRowProps()}>
                {row.cells.map(cell => (
                  <TableCell
                    padding={cell.column.padding}
                    {...cell.getCellProps()}
                  >
                    {cell.render('Cell')}
                  </TableCell>
                ))}
              </TableRow>
            );
          })}
        </TableBody>
      </Table>
      {pagination && (
        <PaginationContainer>
          {loading && <CircularProgress size={30} aria-label='Loading icon' />}
          <TablePagination
            component='nav'
            count={rowCount}
            page={pageIndex}
            rowsPerPage={pageSize}
            onPageChange={onChangePage}
            onRowsPerPageChange={onChangePageSize}
            ActionsComponent={TablePaginationActions}
            labelDisplayedRows={labelDisplayedRows}
            aria-label='Table pagination'
          />
        </PaginationContainer>
      )}
    </Root>
  );
};

const propTypes = {
  title: PropTypes.string,
  data: PropTypes.arrayOf(PropTypes.object).isRequired,
  columns: PropTypes.arrayOf(PropTypes.object).isRequired,
  sortable: PropTypes.bool,
  editable: PropTypes.bool,
  deletable: PropTypes.bool,
  creatable: PropTypes.bool,
  pagination: PropTypes.bool,
  rowsPerPage: PropTypes.number,
  onSaveRow: PropTypes.func,
  onDeleteRow: PropTypes.func,
  id: PropTypes.string,
  fetchData: PropTypes.func,
  rowCount: PropTypes.number,
  loading: PropTypes.bool,
  CreateDialog: PropTypes.func,
  toolbarProps: PropTypes.object,
  hooks: PropTypes.arrayOf(PropTypes.func),
  tableOptions: PropTypes.object,
  tableInitialState: PropTypes.object,
};

const MaterialTableWrapper = (props) => (
  <ConfirmProvider>
    <MaterialTable {...props} />
  </ConfirmProvider>
);

MaterialTableWrapper.propTypes = propTypes;
MaterialTable.propTypes = propTypes;

export { MaterialTableWrapper as MaterialTable };
